{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-dbab384b4f4a6f0d4d0c73d75d18860c2d623948",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Notes.sol": "project/contracts/Notes.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Notes.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ncontract Notes {\r\n    struct Note {\r\n        uint256 id;\r\n        address author;\r\n        string title;\r\n        string content;\r\n        uint256 createdAt;\r\n        uint256 updatedAt;\r\n        bool isPublic;\r\n    }\r\n\r\n    // State variables\r\n    uint256 private nextNoteId;\r\n    mapping(uint256 => Note) private notes;\r\n    mapping(address => uint256[]) private userNoteIds;\r\n    uint256[] private publicNoteIds;\r\n\r\n    // Events\r\n    event NoteCreated(uint256 indexed noteId, address indexed author, string title, bool isPublic);\r\n    event NoteUpdated(uint256 indexed noteId, address indexed author, string title);\r\n    event NoteDeleted(uint256 indexed noteId, address indexed author);\r\n    event NoteVisibilityChanged(uint256 indexed noteId, bool isPublic);\r\n\r\n    // Modifiers\r\n    modifier onlyNoteAuthor(uint256 noteId) {\r\n        require(notes[noteId].author == msg.sender, \"Not the note author\");\r\n        _;\r\n    }\r\n\r\n    modifier noteExists(uint256 noteId) {\r\n        require(notes[noteId].author != address(0), \"Note does not exist\");\r\n        _;\r\n    }\r\n\r\n    // Create a new note\r\n    function createNote(\r\n        string memory title,\r\n        string memory content,\r\n        bool isPublic\r\n    ) external returns (uint256) {\r\n        require(bytes(title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(content).length > 0, \"Content cannot be empty\");\r\n\r\n        uint256 noteId = nextNoteId++;\r\n        \r\n        notes[noteId] = Note({\r\n            id: noteId,\r\n            author: msg.sender,\r\n            title: title,\r\n            content: content,\r\n            createdAt: block.timestamp,\r\n            updatedAt: block.timestamp,\r\n            isPublic: isPublic\r\n        });\r\n\r\n        userNoteIds[msg.sender].push(noteId);\r\n        \r\n        if (isPublic) {\r\n            publicNoteIds.push(noteId);\r\n        }\r\n\r\n        emit NoteCreated(noteId, msg.sender, title, isPublic);\r\n        return noteId;\r\n    }\r\n\r\n    // Update an existing note\r\n    function updateNote(\r\n        uint256 noteId,\r\n        string memory title,\r\n        string memory content\r\n    ) external noteExists(noteId) onlyNoteAuthor(noteId) {\r\n        require(bytes(title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(content).length > 0, \"Content cannot be empty\");\r\n\r\n        Note storage note = notes[noteId];\r\n        note.title = title;\r\n        note.content = content;\r\n        note.updatedAt = block.timestamp;\r\n\r\n        emit NoteUpdated(noteId, msg.sender, title);\r\n    }\r\n\r\n    // Delete a note\r\n    function deleteNote(uint256 noteId) \r\n        external \r\n        noteExists(noteId) \r\n        onlyNoteAuthor(noteId) \r\n    {\r\n        Note memory note = notes[noteId];\r\n        \r\n        // Remove from public notes if it was public\r\n        if (note.isPublic) {\r\n            _removeFromPublicNotes(noteId);\r\n        }\r\n        \r\n        // Remove from user's note list\r\n        _removeFromUserNotes(msg.sender, noteId);\r\n        \r\n        delete notes[noteId];\r\n        \r\n        emit NoteDeleted(noteId, msg.sender);\r\n    }\r\n\r\n    // Toggle note visibility\r\n    function toggleNoteVisibility(uint256 noteId) \r\n        external \r\n        noteExists(noteId) \r\n        onlyNoteAuthor(noteId) \r\n    {\r\n        Note storage note = notes[noteId];\r\n        note.isPublic = !note.isPublic;\r\n        \r\n        if (note.isPublic) {\r\n            publicNoteIds.push(noteId);\r\n        } else {\r\n            _removeFromPublicNotes(noteId);\r\n        }\r\n        \r\n        emit NoteVisibilityChanged(noteId, note.isPublic);\r\n    }\r\n\r\n    // Get a specific note (public or owned by caller)\r\n    function getNote(uint256 noteId) \r\n        external \r\n        view \r\n        noteExists(noteId) \r\n        returns (Note memory) \r\n    {\r\n        Note memory note = notes[noteId];\r\n        require(\r\n            note.isPublic || note.author == msg.sender,\r\n            \"Note is private\"\r\n        );\r\n        return note;\r\n    }\r\n\r\n    // Get all notes by a user\r\n    function getUserNotes(address user) \r\n        external \r\n        view \r\n        returns (Note[] memory) \r\n    {\r\n        uint256[] memory noteIds = userNoteIds[user];\r\n        Note[] memory userNotes = new Note[](noteIds.length);\r\n        \r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            userNotes[i] = notes[noteIds[i]];\r\n        }\r\n        \r\n        return userNotes;\r\n    }\r\n\r\n    // Get all public notes\r\n    function getPublicNotes() external view returns (Note[] memory) {\r\n        Note[] memory publicNotes = new Note[](publicNoteIds.length);\r\n        \r\n        uint256 validCount = 0;\r\n        for (uint256 i = 0; i < publicNoteIds.length; i++) {\r\n            uint256 noteId = publicNoteIds[i];\r\n            if (notes[noteId].author != address(0)) {\r\n                publicNotes[validCount] = notes[noteId];\r\n                validCount++;\r\n            }\r\n        }\r\n        \r\n        // Create array with only valid notes\r\n        Note[] memory result = new Note[](validCount);\r\n        for (uint256 i = 0; i < validCount; i++) {\r\n            result[i] = publicNotes[i];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    // Get user's note count\r\n    function getUserNoteCount(address user) external view returns (uint256) {\r\n        return userNoteIds[user].length;\r\n    }\r\n\r\n    // Get total public note count\r\n    function getPublicNoteCount() external view returns (uint256) {\r\n        return publicNoteIds.length;\r\n    }\r\n\r\n    // Internal helper functions\r\n    function _removeFromPublicNotes(uint256 noteId) private {\r\n        for (uint256 i = 0; i < publicNoteIds.length; i++) {\r\n            if (publicNoteIds[i] == noteId) {\r\n                publicNoteIds[i] = publicNoteIds[publicNoteIds.length - 1];\r\n                publicNoteIds.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeFromUserNotes(address user, uint256 noteId) private {\r\n        uint256[] storage noteIds = userNoteIds[user];\r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            if (noteIds[i] == noteId) {\r\n                noteIds[i] = noteIds[noteIds.length - 1];\r\n                noteIds.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
      }
    }
  }
}