{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-cb605ebad8b2330a7cf3c56da88d8fc6ca12e402",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Notes.sol": "project/contracts/Notes.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Notes.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ncontract Notes {\r\n    struct Note {\r\n        uint256 id;\r\n        address author;\r\n        string title;\r\n        string content;\r\n        uint256 createdAt;\r\n        uint256 updatedAt;\r\n        bool isPublic;\r\n        bool isPinned;\r\n        uint256 tipsReceived;\r\n        uint256 version;\r\n    }\r\n\r\n    struct NoteVersion {\r\n        string title;\r\n        string content;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    // Constants for gas optimization\r\n    uint256 public constant MAX_TITLE_LENGTH = 200;\r\n    uint256 public constant MAX_CONTENT_LENGTH = 5000;\r\n    uint256 public constant MAX_BATCH_SIZE = 10;\r\n\r\n    // State variables\r\n    uint256 private nextNoteId;\r\n    mapping(uint256 => Note) private notes;\r\n    mapping(address => uint256[]) private userNoteIds;\r\n    mapping(address => uint256[]) private pinnedNoteIds;\r\n    uint256[] private publicNoteIds;\r\n    \r\n    // Note versioning\r\n    mapping(uint256 => NoteVersion[]) private noteVersions;\r\n    \r\n    // Tipping\r\n    mapping(uint256 => address[]) private noteTippers;\r\n    mapping(uint256 => mapping(address => uint256)) private tipAmounts;\r\n\r\n    // Events\r\n    event NoteCreated(uint256 indexed noteId, address indexed author, string title, bool isPublic);\r\n    event NoteUpdated(uint256 indexed noteId, address indexed author, string title);\r\n    event NoteDeleted(uint256 indexed noteId, address indexed author);\r\n    event NoteVisibilityChanged(uint256 indexed noteId, bool isPublic);\r\n    event NotePinned(uint256 indexed noteId, address indexed author, bool isPinned);\r\n    event NoteTipped(uint256 indexed noteId, address indexed tipper, address indexed author, uint256 amount);\r\n    event BatchNotesCreated(address indexed author, uint256 count);\r\n\r\n    // Modifiers\r\n    modifier onlyNoteAuthor(uint256 noteId) {\r\n        require(notes[noteId].author == msg.sender, \"Not the note author\");\r\n        _;\r\n    }\r\n\r\n    modifier noteExists(uint256 noteId) {\r\n        require(notes[noteId].author != address(0), \"Note does not exist\");\r\n        _;\r\n    }\r\n\r\n    // Create a new note\r\n    function createNote(\r\n        string memory title,\r\n        string memory content,\r\n        bool isPublic\r\n    ) external returns (uint256) {\r\n        require(bytes(title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(content).length > 0, \"Content cannot be empty\");\r\n        require(bytes(title).length <= MAX_TITLE_LENGTH, \"Title too long\");\r\n        require(bytes(content).length <= MAX_CONTENT_LENGTH, \"Content too long\");\r\n\r\n        uint256 noteId = nextNoteId++;\r\n        \r\n        notes[noteId] = Note({\r\n            id: noteId,\r\n            author: msg.sender,\r\n            title: title,\r\n            content: content,\r\n            createdAt: block.timestamp,\r\n            updatedAt: block.timestamp,\r\n            isPublic: isPublic,\r\n            isPinned: false,\r\n            tipsReceived: 0,\r\n            version: 1\r\n        });\r\n\r\n        userNoteIds[msg.sender].push(noteId);\r\n        \r\n        if (isPublic) {\r\n            publicNoteIds.push(noteId);\r\n        }\r\n\r\n        // Store initial version\r\n        noteVersions[noteId].push(NoteVersion({\r\n            title: title,\r\n            content: content,\r\n            timestamp: block.timestamp\r\n        }));\r\n\r\n        emit NoteCreated(noteId, msg.sender, title, isPublic);\r\n        return noteId;\r\n    }\r\n\r\n    // Batch create notes\r\n    function batchCreateNotes(\r\n        string[] memory titles,\r\n        string[] memory contents,\r\n        bool[] memory isPublicArr\r\n    ) external returns (uint256[] memory) {\r\n        require(titles.length == contents.length, \"Array length mismatch\");\r\n        require(titles.length == isPublicArr.length, \"Array length mismatch\");\r\n        require(titles.length > 0 && titles.length <= MAX_BATCH_SIZE, \"Invalid batch size\");\r\n\r\n        uint256[] memory noteIds = new uint256[](titles.length);\r\n\r\n        for (uint256 i = 0; i < titles.length; i++) {\r\n            require(bytes(titles[i]).length > 0, \"Title cannot be empty\");\r\n            require(bytes(contents[i]).length > 0, \"Content cannot be empty\");\r\n            require(bytes(titles[i]).length <= MAX_TITLE_LENGTH, \"Title too long\");\r\n            require(bytes(contents[i]).length <= MAX_CONTENT_LENGTH, \"Content too long\");\r\n\r\n            uint256 noteId = nextNoteId++;\r\n            \r\n            notes[noteId] = Note({\r\n                id: noteId,\r\n                author: msg.sender,\r\n                title: titles[i],\r\n                content: contents[i],\r\n                createdAt: block.timestamp,\r\n                updatedAt: block.timestamp,\r\n                isPublic: isPublicArr[i],\r\n                isPinned: false,\r\n                tipsReceived: 0,\r\n                version: 1\r\n            });\r\n\r\n            userNoteIds[msg.sender].push(noteId);\r\n            \r\n            if (isPublicArr[i]) {\r\n                publicNoteIds.push(noteId);\r\n            }\r\n\r\n            // Store initial version\r\n            noteVersions[noteId].push(NoteVersion({\r\n                title: titles[i],\r\n                content: contents[i],\r\n                timestamp: block.timestamp\r\n            }));\r\n\r\n            noteIds[i] = noteId;\r\n            emit NoteCreated(noteId, msg.sender, titles[i], isPublicArr[i]);\r\n        }\r\n\r\n        emit BatchNotesCreated(msg.sender, titles.length);\r\n        return noteIds;\r\n    }\r\n\r\n    // Update an existing note\r\n    function updateNote(\r\n        uint256 noteId,\r\n        string memory title,\r\n        string memory content\r\n    ) external noteExists(noteId) onlyNoteAuthor(noteId) {\r\n        require(bytes(title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(content).length > 0, \"Content cannot be empty\");\r\n        require(bytes(title).length <= MAX_TITLE_LENGTH, \"Title too long\");\r\n        require(bytes(content).length <= MAX_CONTENT_LENGTH, \"Content too long\");\r\n\r\n        Note storage note = notes[noteId];\r\n        \r\n        // Store previous version before updating\r\n        noteVersions[noteId].push(NoteVersion({\r\n            title: note.title,\r\n            content: note.content,\r\n            timestamp: note.updatedAt\r\n        }));\r\n\r\n        note.title = title;\r\n        note.content = content;\r\n        note.updatedAt = block.timestamp;\r\n        note.version++;\r\n\r\n        emit NoteUpdated(noteId, msg.sender, title);\r\n    }\r\n\r\n    // Delete a note\r\n    function deleteNote(uint256 noteId) \r\n        external \r\n        noteExists(noteId) \r\n        onlyNoteAuthor(noteId) \r\n    {\r\n        Note memory note = notes[noteId];\r\n        \r\n        // Remove from public notes if it was public\r\n        if (note.isPublic) {\r\n            _removeFromPublicNotes(noteId);\r\n        }\r\n        \r\n        // Remove from pinned notes if it was pinned\r\n        if (note.isPinned) {\r\n            _removeFromPinnedNotes(msg.sender, noteId);\r\n        }\r\n        \r\n        // Remove from user's note list\r\n        _removeFromUserNotes(msg.sender, noteId);\r\n        \r\n        delete notes[noteId];\r\n        delete noteVersions[noteId];\r\n        delete noteTippers[noteId];\r\n        \r\n        emit NoteDeleted(noteId, msg.sender);\r\n    }\r\n\r\n    // Toggle note pin status\r\n    function togglePinNote(uint256 noteId) \r\n        external \r\n        noteExists(noteId) \r\n        onlyNoteAuthor(noteId) \r\n    {\r\n        Note storage note = notes[noteId];\r\n        note.isPinned = !note.isPinned;\r\n        \r\n        if (note.isPinned) {\r\n            pinnedNoteIds[msg.sender].push(noteId);\r\n        } else {\r\n            _removeFromPinnedNotes(msg.sender, noteId);\r\n        }\r\n        \r\n        emit NotePinned(noteId, msg.sender, note.isPinned);\r\n    }\r\n\r\n    // Tip a note author\r\n    function tipNote(uint256 noteId) \r\n        external \r\n        payable \r\n        noteExists(noteId) \r\n    {\r\n        require(msg.value > 0, \"Tip must be greater than 0\");\r\n        Note storage note = notes[noteId];\r\n        require(note.author != msg.sender, \"Cannot tip your own note\");\r\n\r\n        note.tipsReceived += msg.value;\r\n        \r\n        // Track tipper if first time tipping this note\r\n        if (tipAmounts[noteId][msg.sender] == 0) {\r\n            noteTippers[noteId].push(msg.sender);\r\n        }\r\n        tipAmounts[noteId][msg.sender] += msg.value;\r\n\r\n        // Transfer tip to author\r\n        (bool success, ) = payable(note.author).call{value: msg.value}(\"\");\r\n        require(success, \"Tip transfer failed\");\r\n\r\n        emit NoteTipped(noteId, msg.sender, note.author, msg.value);\r\n    }\r\n\r\n    // Toggle note visibility\r\n    function toggleNoteVisibility(uint256 noteId) \r\n        external \r\n        noteExists(noteId) \r\n        onlyNoteAuthor(noteId) \r\n    {\r\n        Note storage note = notes[noteId];\r\n        note.isPublic = !note.isPublic;\r\n        \r\n        if (note.isPublic) {\r\n            publicNoteIds.push(noteId);\r\n        } else {\r\n            _removeFromPublicNotes(noteId);\r\n        }\r\n        \r\n        emit NoteVisibilityChanged(noteId, note.isPublic);\r\n    }\r\n\r\n    // Get a specific note (public or owned by caller)\r\n    function getNote(uint256 noteId) \r\n        external \r\n        view \r\n        noteExists(noteId) \r\n        returns (Note memory) \r\n    {\r\n        Note memory note = notes[noteId];\r\n        require(\r\n            note.isPublic || note.author == msg.sender,\r\n            \"Note is private\"\r\n        );\r\n        return note;\r\n    }\r\n\r\n    // Get all notes by a user\r\n    function getUserNotes(address user) \r\n        external \r\n        view \r\n        returns (Note[] memory) \r\n    {\r\n        uint256[] memory noteIds = userNoteIds[user];\r\n        Note[] memory userNotes = new Note[](noteIds.length);\r\n        \r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            userNotes[i] = notes[noteIds[i]];\r\n        }\r\n        \r\n        return userNotes;\r\n    }\r\n\r\n    // Get all public notes\r\n    function getPublicNotes() external view returns (Note[] memory) {\r\n        Note[] memory publicNotes = new Note[](publicNoteIds.length);\r\n        \r\n        uint256 validCount = 0;\r\n        for (uint256 i = 0; i < publicNoteIds.length; i++) {\r\n            uint256 noteId = publicNoteIds[i];\r\n            if (notes[noteId].author != address(0)) {\r\n                publicNotes[validCount] = notes[noteId];\r\n                validCount++;\r\n            }\r\n        }\r\n        \r\n        // Create array with only valid notes\r\n        Note[] memory result = new Note[](validCount);\r\n        for (uint256 i = 0; i < validCount; i++) {\r\n            result[i] = publicNotes[i];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    // Get user's note count\r\n    function getUserNoteCount(address user) external view returns (uint256) {\r\n        return userNoteIds[user].length;\r\n    }\r\n\r\n    // Get total public note count\r\n    function getPublicNoteCount() external view returns (uint256) {\r\n        return publicNoteIds.length;\r\n    }\r\n\r\n    // Get pinned notes for a user\r\n    function getPinnedNotes(address user) external view returns (Note[] memory) {\r\n        uint256[] memory noteIds = pinnedNoteIds[user];\r\n        Note[] memory pinned = new Note[](noteIds.length);\r\n        \r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            pinned[i] = notes[noteIds[i]];\r\n        }\r\n        \r\n        return pinned;\r\n    }\r\n\r\n    // Get note version history\r\n    function getNoteVersions(uint256 noteId) \r\n        external \r\n        view \r\n        noteExists(noteId)\r\n        returns (NoteVersion[] memory) \r\n    {\r\n        Note memory note = notes[noteId];\r\n        require(\r\n            note.isPublic || note.author == msg.sender,\r\n            \"Note is private\"\r\n        );\r\n        return noteVersions[noteId];\r\n    }\r\n\r\n    // Get tippers for a note\r\n    function getNoteTippers(uint256 noteId) \r\n        external \r\n        view \r\n        noteExists(noteId)\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        address[] memory tippers = noteTippers[noteId];\r\n        uint256[] memory amounts = new uint256[](tippers.length);\r\n        \r\n        for (uint256 i = 0; i < tippers.length; i++) {\r\n            amounts[i] = tipAmounts[noteId][tippers[i]];\r\n        }\r\n        \r\n        return (tippers, amounts);\r\n    }\r\n\r\n    // Get tip amount from a specific tipper for a note\r\n    function getTipAmount(uint256 noteId, address tipper) \r\n        external \r\n        view \r\n        returns (uint256) \r\n    {\r\n        return tipAmounts[noteId][tipper];\r\n    }\r\n\r\n    // Internal helper functions\r\n    function _removeFromPublicNotes(uint256 noteId) private {\r\n        for (uint256 i = 0; i < publicNoteIds.length; i++) {\r\n            if (publicNoteIds[i] == noteId) {\r\n                publicNoteIds[i] = publicNoteIds[publicNoteIds.length - 1];\r\n                publicNoteIds.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeFromUserNotes(address user, uint256 noteId) private {\r\n        uint256[] storage noteIds = userNoteIds[user];\r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            if (noteIds[i] == noteId) {\r\n                noteIds[i] = noteIds[noteIds.length - 1];\r\n                noteIds.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeFromPinnedNotes(address user, uint256 noteId) private {\r\n        uint256[] storage noteIds = pinnedNoteIds[user];\r\n        for (uint256 i = 0; i < noteIds.length; i++) {\r\n            if (noteIds[i] == noteId) {\r\n                noteIds[i] = noteIds[noteIds.length - 1];\r\n                noteIds.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
      }
    }
  }
}